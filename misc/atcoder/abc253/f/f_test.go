// Code generated by copypasta/template/atcoder/generator_test.go
package main

import (
	. "fmt"
	"github.com/EndlessCheng/codeforces-go/main/testutil"
	"io"
	"testing"
)

var 	testCases = [][2]string{
	{
		`3 3 9
1 1 2 1
3 2 2
2 3 2
3 3 3
3 3 1
1 2 3 3
3 3 2
3 2 3
3 1 2`,
		`1
2
2
5
3
4`,
	},
	{
		`1 1 10
1 1 1 1000000000
1 1 1 1000000000
1 1 1 1000000000
1 1 1 1000000000
1 1 1 1000000000
1 1 1 1000000000
1 1 1 1000000000
1 1 1 1000000000
1 1 1 1000000000
3 1 1`,
		`9000000000`,
	},
	{
		`10 10 10
1 1 8 5
2 2 6
3 2 1
3 4 7
1 5 9 7
3 3 2
3 2 8
2 8 10
3 8 8
3 1 10`,
		`6
5
5
13
10
0`,
	},
	{
		`2 2 3
1 1 1 3
1 1 2 1
3 1 1`,
		`4`,
	},
	{
		`2 2 2
1 1 2 3
3 1 1`,
		`3`,
	},
}

// 提交地址：https://atcoder.jp/contests/abc253/submit?taskScreenName=abc253_f
func Test_run(t *testing.T) {
	t.Log("Current test is [f]")

	testutil.AssertEqualStringCase(t, testCases, 0, run)
}

// https://atcoder.jp/contests/abc253/tasks/abc253_f

func TestCompare(t *testing.T) {
	//return
	testutil.DebugTLE = 0

	inputGenerator := func() string {
		//return ``
		rg := testutil.NewRandGenerator()
		n := rg.Int(1, 3)
		m := rg.Int(1, 3)
		q := rg.Int(1, 3)
		rg.NewLine()
		for qi := 0; qi < q; qi++ {
			op := rg.Int(1, 3)
			if op == 1 {
				l := rg.Int(1, m)
				rg.Int(l, m)
				rg.Int(1, 3)
			} else if op == 2 {
				rg.Int(1, n)
				rg.Int(1, 3)
			} else {
				rg.Int(1, n)
				rg.Int(1, m)
			}
			rg.NewLine()
		}
		return rg.String()
	}

	// 先用 runBF 跑下样例，检查 runBF 是否正确
	//testutil.AssertEqualStringCase(t, testCases, 0, runAC)
	//return

	testutil.AssertEqualRunResultsInf(t, inputGenerator, runAC, run)
}

func solveComentary(n, m, q int, t, a, b, c []int) (ans []int) {
	latest := make([][2]int, n)
	for i := 0; i < n; i++ {
		latest[i] = [2]int{-1, 0}
	}
	offset := make([][]int, q)
	aid := make([]int, q)
	for i := range t {
		switch t[i] {
		case 2:
			latest[a[i]] = [2]int{i, b[i]}
		case 3:
			idx := len(ans)
			aid[i] = idx
			j, x := latest[a[i]][0], latest[a[i]][1]
			ans = append(ans, x)
			if j >= 0 {
				offset[j] = append(offset[j], i)
			}
		}
	}
	fen := NewFenwickTree(m)
	for i := range t {
		switch t[i] {
		case 1:
			fen.Add(a[i], c[i])
			fen.Add(b[i], -c[i])
		case 2:
			//sq := query.(SubstitutionQuery)
			for _, v := range offset[i] {
				ans[aid[v]] -= fen.Sum(0, b[v])
			}
		case 3:
			ans[aid[i]] += fen.Sum(0, b[i])
		}
	}
	return ans
}

func runAC(_r io.Reader, out io.Writer) {
	_i, _n, buf := 0, 0, make([]byte, 1<<12)
	rc := func() byte {
		if _i == _n {
			_n, _ = _r.Read(buf)
			if _n == 0 {
				return 0
			}
			_i = 0
		}
		b := buf[_i]
		_i++
		return b
	}
	nextInt := func() (x int) {
		b := rc()
		for ; '0' > b; b = rc() {
		}
		for ; '0' <= b; b = rc() {
			x = x*10 + int(b&15)
		}
		return
	}
	n, m, q := nextInt(), nextInt(), nextInt()
	var t []int
	a, b, c := make([]int, q), make([]int, q), make([]int, q)
	for i := 0; i < q; i++ {
		t = append(t, nextInt())
		switch t[i] {
		case 1:
			a[i] = nextInt()
			b[i] = nextInt()
			c[i] = nextInt()
			// 0-indexed
			a[i]--
		case 2:
			a[i] = nextInt()
			b[i] = nextInt()
			// 0-indexed
			a[i]--
		case 3:
			a[i] = nextInt()
			b[i] = nextInt()
			// 0-indexed
			a[i]--
		}
	}

	ans := solveComentary(n, m, q, t, a, b, c)

	for _, v := range ans {
		Fprintln(out, v)
	}
}

func Abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func Min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

func Max(x, y int) int {
	if x < y {
		return y
	}
	return x
}

func Floor(x, y int) int {
	return x / y
}

func Ceil(x, y int) int {
	return (x + y - 1) / y
}

type FenwickTree struct {
	n     int
	nodes []int
}

func NewFenwickTree(n int) *FenwickTree {
	fen := new(FenwickTree)
	fen.n = n + 1
	fen.nodes = make([]int, fen.n)
	return fen
}

func (fen *FenwickTree) Add(i, v int) {
	i++
	for i <= fen.n {
		fen.nodes[i-1] += v
		i += i & -i
	}
}

func (fen *FenwickTree) Sum(l, r int) int {
	return fen.sum(r) - fen.sum(l)
}

func (fen *FenwickTree) sum(i int) int {
	res := 0
	for i > 0 {
		res += fen.nodes[i-1]
		i -= i & -i
	}
	return res
}
